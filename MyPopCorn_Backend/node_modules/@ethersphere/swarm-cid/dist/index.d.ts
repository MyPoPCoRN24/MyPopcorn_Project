import { CID } from 'multiformats';
export declare const KECCAK_256_CODEC = 27;
export declare const SWARM_NS_CODEC = 228;
export declare const SWARM_MANIFEST_CODEC = 250;
export declare const SWARM_FEED_CODEC = 251;
export declare const REFERENCE_HEX_LENGTH = 64;
export declare type Reference = HexString<typeof REFERENCE_HEX_LENGTH>;
export declare enum ReferenceType {
    FEED = "feed",
    MANIFEST = "manifest"
}
export interface DecodeResult {
    /**
     * Hex encoded Reference
     */
    reference: Reference;
    /**
     * If the CID had one of the Swarm related codecs than this specifies the type of content
     */
    type?: ReferenceType;
}
/**
 * Encode Swarm hex-encoded Reference into CID that has appropriate codec set based on `type` parameter.
 *
 * @param ref
 * @param type
 */
export declare function encodeReference(ref: string | Reference, type: ReferenceType): CID;
/**
 * Encode Swarm hex-encoded Reference into CID and sets Feed codec.
 * @param ref
 */
export declare function encodeFeedReference(ref: string | Reference): CID;
/**
 * Encode Swarm hex-encoded Reference into CID and sets Manifest codec.
 * @param ref
 */
export declare function encodeManifestReference(ref: string | Reference): CID;
/**
 * Function to decode Feed CID (both from string or CID instance) into hex encoded Swarm reference.
 *
 * @param cid
 * @throws Error if the decoded codec did not matched Swarm Feed codec
 */
export declare function decodeFeedCid(cid: CID | string): Reference;
/**
 * Function to decode Manifest CID (both from string or CID instance) into hex encoded Swarm reference.
 *
 * @param cid
 * @throws Error if the decoded codec did not matched Swarm Manifest codec
 */
export declare function decodeManifestCid(cid: CID | string): Reference;
/**
 * Decode CID or base encoded CID string into DecodeResult interface.
 * Does not throw exception if the codec was not Swarm related. In that case `type` is undefined.
 *
 * @see DecodeResult
 * @param cid
 */
export declare function decodeCid(cid: CID | string): DecodeResult;
declare type FlavoredType<Type, Name> = Type & {
    __tag__?: Name;
};
/**
 * Nominal type to represent hex strings WITHOUT '0x' prefix.
 * For example for 32 bytes hex representation you have to use 64 length.
 */
declare type HexString<Length extends number = number> = FlavoredType<string & {
    readonly length: Length;
}, 'HexString'>;
export {};
