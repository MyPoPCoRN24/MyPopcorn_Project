"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeBytesReference = void 0;
const types_1 = require("../types");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
function makeBytesReference(reference, offset = 0) {
    if (typeof reference === 'string') {
        if (offset) {
            throw new Error('Offset property can be set only for UintArray reference!');
        }
        try {
            // Non-encrypted chunk hex string reference
            const hexReference = (0, hex_1.makeHexString)(reference, types_1.REFERENCE_HEX_LENGTH);
            return (0, hex_1.hexToBytes)(hexReference);
        }
        catch (e) {
            if (!(e instanceof TypeError)) {
                throw e;
            }
            // Encrypted chunk hex string reference
            const hexReference = (0, hex_1.makeHexString)(reference, types_1.ENCRYPTED_REFERENCE_HEX_LENGTH);
            return (0, hex_1.hexToBytes)(hexReference);
        }
    }
    else if (reference instanceof Uint8Array) {
        if ((0, bytes_1.hasBytesAtOffset)(reference, offset, types_1.ENCRYPTED_REFERENCE_BYTES_LENGTH)) {
            return (0, bytes_1.bytesAtOffset)(reference, offset, types_1.ENCRYPTED_REFERENCE_BYTES_LENGTH);
        }
        else if ((0, bytes_1.hasBytesAtOffset)(reference, offset, types_1.REFERENCE_BYTES_LENGTH)) {
            return (0, bytes_1.bytesAtOffset)(reference, offset, types_1.REFERENCE_BYTES_LENGTH);
        }
    }
    throw new TypeError('invalid chunk reference');
}
exports.makeBytesReference = makeBytesReference;
