"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadReadable = exports.download = exports.upload = void 0;
const bytes_1 = require("../utils/bytes");
const headers_1 = require("../utils/headers");
const http_1 = require("../utils/http");
const type_1 = require("../utils/type");
const endpoint = 'bytes';
/**
 * Upload data to a Bee node
 *
 * @param requestOptions Options for making requests
 * @param data            Data to be uploaded
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Additional options like tag, encryption, pinning
 */
async function upload(requestOptions, data, postageBatchId, options) {
    const response = await (0, http_1.http)(requestOptions, {
        url: endpoint,
        method: 'post',
        responseType: 'json',
        data,
        headers: {
            'content-type': 'application/octet-stream',
            ...(0, headers_1.extractRedundantUploadHeaders)(postageBatchId, options),
        },
    });
    return {
        reference: response.data.reference,
        tagUid: response.headers['swarm-tag'] ? (0, type_1.makeTagUid)(response.headers['swarm-tag']) : undefined,
    };
}
exports.upload = upload;
/**
 * Download data as a byte array
 *
 * @param requestOptions Options for making requests
 * @param hash Bee content reference
 */
async function download(requestOptions, hash, options) {
    const response = await (0, http_1.http)(requestOptions, {
        responseType: 'arraybuffer',
        url: `${endpoint}/${hash}`,
        headers: (0, headers_1.extractDownloadHeaders)(options),
    });
    return (0, bytes_1.wrapBytesWithHelpers)(new Uint8Array(response.data));
}
exports.download = download;
/**
 * Download data as a readable stream
 *
 * @param requestOptions Options for making requests
 * @param hash Bee content reference
 */
async function downloadReadable(requestOptions, hash, options) {
    const response = await (0, http_1.http)(requestOptions, {
        responseType: 'stream',
        url: `${endpoint}/${hash}`,
        headers: (0, headers_1.extractDownloadHeaders)(options),
    });
    return response.data;
}
exports.downloadReadable = downloadReadable;
