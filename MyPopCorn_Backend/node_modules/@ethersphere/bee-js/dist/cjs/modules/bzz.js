"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadCollection = exports.extractCollectionUploadHeaders = exports.downloadFileReadable = exports.downloadFile = exports.uploadFile = void 0;
const bytes_1 = require("../utils/bytes");
const collection_1 = require("../utils/collection");
const headers_1 = require("../utils/headers");
const http_1 = require("../utils/http");
const tar_uploader_1 = require("../utils/tar-uploader");
const type_1 = require("../utils/type");
const bzzEndpoint = 'bzz';
function extractFileUploadHeaders(postageBatchId, options) {
    const headers = (0, headers_1.extractRedundantUploadHeaders)(postageBatchId, options);
    if (options?.size)
        headers['content-length'] = String(options.size);
    if (options?.contentType)
        headers['content-type'] = options.contentType;
    return headers;
}
/**
 * Upload single file
 *
 * @param requestOptions Options for making requests
 * @param data Files data
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param name Name that will be attached to the uploaded file. Wraps the data into manifest with set index document.
 * @param options
 */
async function uploadFile(requestOptions, data, postageBatchId, name, options) {
    if ((0, type_1.isReadable)(data) && !options?.contentType) {
        if (!options) {
            options = {};
        }
        options.contentType = 'application/octet-stream';
    }
    const response = await (0, http_1.http)(requestOptions, {
        method: 'post',
        url: bzzEndpoint,
        data,
        headers: {
            ...extractFileUploadHeaders(postageBatchId, options),
        },
        params: { name },
        responseType: 'json',
    });
    return {
        reference: response.data.reference,
        tagUid: response.headers['swarm-tag'] ? (0, type_1.makeTagUid)(response.headers['swarm-tag']) : undefined,
    };
}
exports.uploadFile = uploadFile;
/**
 * Download single file as a buffer
 *
 * @param requestOptions Options for making requests
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */
async function downloadFile(requestOptions, hash, path = '', options) {
    const response = await (0, http_1.http)(requestOptions, {
        method: 'GET',
        responseType: 'arraybuffer',
        url: `${bzzEndpoint}/${hash}/${path}`,
        headers: (0, headers_1.extractDownloadHeaders)(options),
    });
    const file = {
        ...(0, headers_1.readFileHeaders)(response.headers),
        data: (0, bytes_1.wrapBytesWithHelpers)(new Uint8Array(response.data)),
    };
    return file;
}
exports.downloadFile = downloadFile;
/**
 * Download single file as a readable stream
 *
 * @param requestOptions Options for making requests
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */
async function downloadFileReadable(requestOptions, hash, path = '', options) {
    const response = await (0, http_1.http)(requestOptions, {
        method: 'GET',
        responseType: 'stream',
        url: `${bzzEndpoint}/${hash}/${path}`,
        headers: (0, headers_1.extractDownloadHeaders)(options),
    });
    const file = {
        ...(0, headers_1.readFileHeaders)(response.headers),
        data: response.data,
    };
    return file;
}
exports.downloadFileReadable = downloadFileReadable;
function extractCollectionUploadHeaders(postageBatchId, options) {
    const headers = (0, headers_1.extractRedundantUploadHeaders)(postageBatchId, options);
    if (options?.indexDocument) {
        headers['swarm-index-document'] = options.indexDocument;
    }
    if (options?.errorDocument) {
        headers['swarm-error-document'] = options.errorDocument;
    }
    return headers;
}
exports.extractCollectionUploadHeaders = extractCollectionUploadHeaders;
/**
 * Upload collection
 * @param requestOptions Options for making requests
 * @param collection Collection of Uint8Array buffers to upload
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options
 */
async function uploadCollection(requestOptions, collection, postageBatchId, options) {
    (0, collection_1.assertCollection)(collection);
    const response = await (0, tar_uploader_1.uploadTar)(requestOptions, collection, postageBatchId, options);
    return {
        reference: response.data.reference,
        tagUid: response.headers['swarm-tag'] ? (0, type_1.makeTagUid)(response.headers['swarm-tag']) : undefined,
    };
}
exports.uploadCollection = uploadCollection;
