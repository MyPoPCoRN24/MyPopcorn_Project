"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeFeedWriter = exports.makeFeedReader = exports.downloadFeedUpdate = exports.getFeedUpdateChunkReference = exports.updateFeed = exports.findNextIndex = void 0;
const cafe_utility_1 = require("cafe-utility");
const soc_1 = require("../chunk/soc");
const chunkAPI = __importStar(require("../modules/chunk"));
const feed_1 = require("../modules/feed");
const types_1 = require("../types");
const bytes_1 = require("../utils/bytes");
const eth_1 = require("../utils/eth");
const hash_1 = require("../utils/hash");
const hex_1 = require("../utils/hex");
const reference_1 = require("../utils/reference");
const type_1 = require("../utils/type");
const identifier_1 = require("./identifier");
const TIMESTAMP_PAYLOAD_OFFSET = 0;
const TIMESTAMP_PAYLOAD_SIZE = 8;
const REFERENCE_PAYLOAD_OFFSET = TIMESTAMP_PAYLOAD_SIZE;
async function findNextIndex(requestOptions, owner, topic, options) {
    try {
        const feedUpdate = await (0, feed_1.fetchLatestFeedUpdate)(requestOptions, owner, topic, options);
        return (0, hex_1.makeHexString)(feedUpdate.feedIndexNext, types_1.FEED_INDEX_HEX_LENGTH);
    }
    catch (e) {
        if (e?.response?.status === 404) {
            return (0, hex_1.bytesToHex)((0, bytes_1.makeBytes)(8));
        }
        throw e;
    }
}
exports.findNextIndex = findNextIndex;
async function updateFeed(requestOptions, signer, topic, reference, postageBatchId, options) {
    const ownerHex = (0, eth_1.makeHexEthAddress)(signer.address);
    const nextIndex = options?.index ?? (await findNextIndex(requestOptions, ownerHex, topic, options));
    const identifier = (0, identifier_1.makeFeedIdentifier)(topic, nextIndex);
    const at = options?.at ?? Date.now() / 1000.0;
    const timestamp = cafe_utility_1.Binary.numberToUint64BE(Math.floor(at));
    const payloadBytes = cafe_utility_1.Binary.concatBytes(timestamp, reference);
    return (0, soc_1.uploadSingleOwnerChunkData)(requestOptions, signer, postageBatchId, identifier, payloadBytes, options);
}
exports.updateFeed = updateFeed;
function getFeedUpdateChunkReference(owner, topic, index) {
    const identifier = (0, identifier_1.makeFeedIdentifier)(topic, index);
    return (0, hash_1.keccak256Hash)(identifier, owner);
}
exports.getFeedUpdateChunkReference = getFeedUpdateChunkReference;
async function downloadFeedUpdate(requestOptions, owner, topic, index) {
    const address = getFeedUpdateChunkReference(owner, topic, index);
    const addressHex = (0, hex_1.bytesToHex)(address);
    const data = await chunkAPI.download(requestOptions, addressHex);
    const soc = (0, soc_1.makeSingleOwnerChunkFromData)(data, address);
    const payload = soc.payload();
    const timestampBytes = (0, bytes_1.bytesAtOffset)(payload, TIMESTAMP_PAYLOAD_OFFSET, TIMESTAMP_PAYLOAD_SIZE);
    const timestamp = cafe_utility_1.Binary.uint64BEToNumber(timestampBytes);
    const reference = (0, reference_1.makeBytesReference)(payload, REFERENCE_PAYLOAD_OFFSET);
    return {
        timestamp,
        reference,
    };
}
exports.downloadFeedUpdate = downloadFeedUpdate;
function makeFeedReader(requestOptions, type, topic, owner) {
    return {
        type,
        owner,
        topic,
        async download(options) {
            if (!options?.index && options?.index !== 0) {
                return (0, feed_1.fetchLatestFeedUpdate)(requestOptions, owner, topic);
            }
            const update = await downloadFeedUpdate(requestOptions, (0, hex_1.hexToBytes)(owner), topic, options.index);
            return {
                reference: (0, hex_1.bytesToHex)(update.reference),
                feedIndex: options.index,
                feedIndexNext: '',
            };
        },
    };
}
exports.makeFeedReader = makeFeedReader;
function makeFeedWriter(requestOptions, type, topic, signer) {
    const upload = async (postageBatchId, reference, options) => {
        (0, type_1.assertAddress)(postageBatchId);
        const canonicalReference = (0, reference_1.makeBytesReference)(reference);
        return updateFeed(requestOptions, signer, topic, canonicalReference, postageBatchId, { ...options, type });
    };
    return {
        ...makeFeedReader(requestOptions, type, topic, (0, eth_1.makeHexEthAddress)(signer.address)),
        upload,
    };
}
exports.makeFeedWriter = makeFeedWriter;
