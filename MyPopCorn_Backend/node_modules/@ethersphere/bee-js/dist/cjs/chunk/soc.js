"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadSingleOwnerChunk = exports.uploadSingleOwnerChunkData = exports.uploadSingleOwnerChunk = exports.makeSingleOwnerChunk = exports.makeSOCAddress = exports.makeSingleOwnerChunkFromData = void 0;
const cafe_utility_1 = require("cafe-utility");
const chunkAPI = __importStar(require("../modules/chunk"));
const socAPI = __importStar(require("../modules/soc"));
const bytes_1 = require("../utils/bytes");
const error_1 = require("../utils/error");
const hash_1 = require("../utils/hash");
const hex_1 = require("../utils/hex");
const type_1 = require("../utils/type");
const bmt_1 = require("./bmt");
const cac_1 = require("./cac");
const signer_1 = require("./signer");
const span_1 = require("./span");
const IDENTIFIER_SIZE = 32;
const SIGNATURE_SIZE = 65;
const SOC_IDENTIFIER_OFFSET = 0;
const SOC_SIGNATURE_OFFSET = SOC_IDENTIFIER_OFFSET + IDENTIFIER_SIZE;
const SOC_SPAN_OFFSET = SOC_SIGNATURE_OFFSET + SIGNATURE_SIZE;
const SOC_PAYLOAD_OFFSET = SOC_SPAN_OFFSET + span_1.SPAN_SIZE;
function recoverChunkOwner(data) {
    const cacData = data.slice(SOC_SPAN_OFFSET);
    const chunkAddress = (0, bmt_1.bmtHash)(cacData);
    const signature = (0, bytes_1.bytesAtOffset)(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);
    const identifier = (0, bytes_1.bytesAtOffset)(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
    const digest = (0, hash_1.keccak256Hash)(identifier, chunkAddress);
    const ownerAddress = (0, signer_1.recoverAddress)(signature, digest);
    return ownerAddress;
}
/**
 * Verifies if the data is a valid single owner chunk
 *
 * @param data    The chunk data
 * @param address The address of the single owner chunk
 *
 * @returns a single owner chunk or throws error
 */
function makeSingleOwnerChunkFromData(data, address) {
    const ownerAddress = recoverChunkOwner(data);
    const identifier = (0, bytes_1.bytesAtOffset)(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
    const socAddress = (0, hash_1.keccak256Hash)(identifier, ownerAddress);
    if (!(0, bytes_1.bytesEqual)(address, socAddress)) {
        throw new error_1.BeeError('SOC Data does not match given address!');
    }
    const signature = () => (0, bytes_1.bytesAtOffset)(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);
    const span = () => (0, bytes_1.bytesAtOffset)(data, SOC_SPAN_OFFSET, span_1.SPAN_SIZE);
    const payload = () => (0, bytes_1.flexBytesAtOffset)(data, SOC_PAYLOAD_OFFSET, cac_1.MIN_PAYLOAD_SIZE, cac_1.MAX_PAYLOAD_SIZE);
    return {
        data,
        identifier: () => identifier,
        signature,
        span,
        payload,
        address: () => socAddress,
        owner: () => ownerAddress,
    };
}
exports.makeSingleOwnerChunkFromData = makeSingleOwnerChunkFromData;
function makeSOCAddress(identifier, address) {
    return (0, hash_1.keccak256Hash)(identifier, address);
}
exports.makeSOCAddress = makeSOCAddress;
/**
 * Creates a single owner chunk object
 *
 * @param chunk       A chunk object used for the span and payload
 * @param identifier  The identifier of the chunk
 * @param signer      The singer interface for signing the chunk
 */
async function makeSingleOwnerChunk(chunk, identifier, signer) {
    const chunkAddress = chunk.address();
    (0, cac_1.assertValidChunkData)(chunk.data, chunkAddress);
    const digest = (0, hash_1.keccak256Hash)(identifier, chunkAddress);
    const signature = await (0, signer_1.sign)(signer, digest);
    const data = cafe_utility_1.Binary.concatBytes(identifier, signature, chunk.span(), chunk.payload());
    const address = makeSOCAddress(identifier, signer.address);
    return {
        data,
        identifier: () => identifier,
        signature: () => signature,
        span: () => chunk.span(),
        payload: () => chunk.payload(),
        address: () => address,
        owner: () => signer.address,
    };
}
exports.makeSingleOwnerChunk = makeSingleOwnerChunk;
/**
 * Helper function to upload a chunk.
 *
 * It uses the Chunk API and calculates the address before uploading.
 *
 * @param requestOptions  Options for making requests
 * @param chunk           A chunk object
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Upload options
 */
async function uploadSingleOwnerChunk(requestOptions, chunk, postageBatchId, options) {
    const owner = (0, hex_1.bytesToHex)(chunk.owner());
    const identifier = (0, hex_1.bytesToHex)(chunk.identifier());
    const signature = (0, hex_1.bytesToHex)(chunk.signature());
    const data = cafe_utility_1.Binary.concatBytes(chunk.span(), chunk.payload());
    return socAPI.upload(requestOptions, owner, identifier, signature, data, postageBatchId, options);
}
exports.uploadSingleOwnerChunk = uploadSingleOwnerChunk;
/**
 * Helper function to create and upload SOC.
 *
 * @param requestOptions  Options for making requests
 * @param signer          The singer interface for signing the chunk
 * @param postageBatchId
 * @param identifier      The identifier of the chunk
 * @param data            The chunk data
 * @param options
 */
async function uploadSingleOwnerChunkData(requestOptions, signer, postageBatchId, identifier, data, options) {
    (0, type_1.assertAddress)(postageBatchId);
    const cac = (0, cac_1.makeContentAddressedChunk)(data);
    const soc = await makeSingleOwnerChunk(cac, identifier, signer);
    return uploadSingleOwnerChunk(requestOptions, soc, postageBatchId, options);
}
exports.uploadSingleOwnerChunkData = uploadSingleOwnerChunkData;
/**
 * Helper function to download SOC.
 *
 * @param url           The url of the Bee service
 * @param ownerAddress  The singer interface for signing the chunk
 * @param identifier    The identifier of the chunk
 */
async function downloadSingleOwnerChunk(requestOptions, ownerAddress, identifier) {
    const address = makeSOCAddress(identifier, ownerAddress);
    const data = await chunkAPI.download(requestOptions, (0, hex_1.bytesToHex)(address));
    return makeSingleOwnerChunkFromData(data, address);
}
exports.downloadSingleOwnerChunk = downloadSingleOwnerChunk;
