import { wrapBytesWithHelpers } from "../utils/bytes.js";
import { assertCollection } from "../utils/collection.js";
import { extractDownloadHeaders, extractRedundantUploadHeaders, readFileHeaders } from "../utils/headers.js";
import { http } from "../utils/http.js";
import { uploadTar } from "../utils/tar-uploader.js";
import { isReadable, makeTagUid } from "../utils/type.js";
const bzzEndpoint = 'bzz';
function extractFileUploadHeaders(postageBatchId, options) {
  const headers = extractRedundantUploadHeaders(postageBatchId, options);
  if (options?.size) headers['content-length'] = String(options.size);
  if (options?.contentType) headers['content-type'] = options.contentType;
  return headers;
}
/**
 * Upload single file
 *
 * @param requestOptions Options for making requests
 * @param data Files data
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param name Name that will be attached to the uploaded file. Wraps the data into manifest with set index document.
 * @param options
 */
export async function uploadFile(requestOptions, data, postageBatchId, name, options) {
  if (isReadable(data) && !options?.contentType) {
    if (!options) {
      options = {};
    }
    options.contentType = 'application/octet-stream';
  }
  const response = await http(requestOptions, {
    method: 'post',
    url: bzzEndpoint,
    data,
    headers: {
      ...extractFileUploadHeaders(postageBatchId, options)
    },
    params: {
      name
    },
    responseType: 'json'
  });
  return {
    reference: response.data.reference,
    tagUid: response.headers['swarm-tag'] ? makeTagUid(response.headers['swarm-tag']) : undefined
  };
}
/**
 * Download single file as a buffer
 *
 * @param requestOptions Options for making requests
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */
export async function downloadFile(requestOptions, hash, path = '', options) {
  const response = await http(requestOptions, {
    method: 'GET',
    responseType: 'arraybuffer',
    url: `${bzzEndpoint}/${hash}/${path}`,
    headers: extractDownloadHeaders(options)
  });
  const file = {
    ...readFileHeaders(response.headers),
    data: wrapBytesWithHelpers(new Uint8Array(response.data))
  };
  return file;
}
/**
 * Download single file as a readable stream
 *
 * @param requestOptions Options for making requests
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */
export async function downloadFileReadable(requestOptions, hash, path = '', options) {
  const response = await http(requestOptions, {
    method: 'GET',
    responseType: 'stream',
    url: `${bzzEndpoint}/${hash}/${path}`,
    headers: extractDownloadHeaders(options)
  });
  const file = {
    ...readFileHeaders(response.headers),
    data: response.data
  };
  return file;
}
export function extractCollectionUploadHeaders(postageBatchId, options) {
  const headers = extractRedundantUploadHeaders(postageBatchId, options);
  if (options?.indexDocument) {
    headers['swarm-index-document'] = options.indexDocument;
  }
  if (options?.errorDocument) {
    headers['swarm-error-document'] = options.errorDocument;
  }
  return headers;
}
/**
 * Upload collection
 * @param requestOptions Options for making requests
 * @param collection Collection of Uint8Array buffers to upload
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options
 */
export async function uploadCollection(requestOptions, collection, postageBatchId, options) {
  assertCollection(collection);
  const response = await uploadTar(requestOptions, collection, postageBatchId, options);
  return {
    reference: response.data.reference,
    tagUid: response.headers['swarm-tag'] ? makeTagUid(response.headers['swarm-tag']) : undefined
  };
}