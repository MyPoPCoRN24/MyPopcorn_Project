import { Binary } from 'cafe-utility';
import * as chunkAPI from "../modules/chunk.js";
import * as socAPI from "../modules/soc.js";
import { bytesAtOffset, bytesEqual, flexBytesAtOffset } from "../utils/bytes.js";
import { BeeError } from "../utils/error.js";
import { keccak256Hash } from "../utils/hash.js";
import { bytesToHex } from "../utils/hex.js";
import { assertAddress } from "../utils/type.js";
import { bmtHash } from "./bmt.js";
import { MAX_PAYLOAD_SIZE, MIN_PAYLOAD_SIZE, assertValidChunkData, makeContentAddressedChunk } from "./cac.js";
import { recoverAddress, sign } from "./signer.js";
import { SPAN_SIZE } from "./span.js";
const IDENTIFIER_SIZE = 32;
const SIGNATURE_SIZE = 65;
const SOC_IDENTIFIER_OFFSET = 0;
const SOC_SIGNATURE_OFFSET = SOC_IDENTIFIER_OFFSET + IDENTIFIER_SIZE;
const SOC_SPAN_OFFSET = SOC_SIGNATURE_OFFSET + SIGNATURE_SIZE;
const SOC_PAYLOAD_OFFSET = SOC_SPAN_OFFSET + SPAN_SIZE;
function recoverChunkOwner(data) {
  const cacData = data.slice(SOC_SPAN_OFFSET);
  const chunkAddress = bmtHash(cacData);
  const signature = bytesAtOffset(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);
  const identifier = bytesAtOffset(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
  const digest = keccak256Hash(identifier, chunkAddress);
  const ownerAddress = recoverAddress(signature, digest);
  return ownerAddress;
}
/**
 * Verifies if the data is a valid single owner chunk
 *
 * @param data    The chunk data
 * @param address The address of the single owner chunk
 *
 * @returns a single owner chunk or throws error
 */
export function makeSingleOwnerChunkFromData(data, address) {
  const ownerAddress = recoverChunkOwner(data);
  const identifier = bytesAtOffset(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
  const socAddress = keccak256Hash(identifier, ownerAddress);
  if (!bytesEqual(address, socAddress)) {
    throw new BeeError('SOC Data does not match given address!');
  }
  const signature = () => bytesAtOffset(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);
  const span = () => bytesAtOffset(data, SOC_SPAN_OFFSET, SPAN_SIZE);
  const payload = () => flexBytesAtOffset(data, SOC_PAYLOAD_OFFSET, MIN_PAYLOAD_SIZE, MAX_PAYLOAD_SIZE);
  return {
    data,
    identifier: () => identifier,
    signature,
    span,
    payload,
    address: () => socAddress,
    owner: () => ownerAddress
  };
}
export function makeSOCAddress(identifier, address) {
  return keccak256Hash(identifier, address);
}
/**
 * Creates a single owner chunk object
 *
 * @param chunk       A chunk object used for the span and payload
 * @param identifier  The identifier of the chunk
 * @param signer      The singer interface for signing the chunk
 */
export async function makeSingleOwnerChunk(chunk, identifier, signer) {
  const chunkAddress = chunk.address();
  assertValidChunkData(chunk.data, chunkAddress);
  const digest = keccak256Hash(identifier, chunkAddress);
  const signature = await sign(signer, digest);
  const data = Binary.concatBytes(identifier, signature, chunk.span(), chunk.payload());
  const address = makeSOCAddress(identifier, signer.address);
  return {
    data,
    identifier: () => identifier,
    signature: () => signature,
    span: () => chunk.span(),
    payload: () => chunk.payload(),
    address: () => address,
    owner: () => signer.address
  };
}
/**
 * Helper function to upload a chunk.
 *
 * It uses the Chunk API and calculates the address before uploading.
 *
 * @param requestOptions  Options for making requests
 * @param chunk           A chunk object
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Upload options
 */
export async function uploadSingleOwnerChunk(requestOptions, chunk, postageBatchId, options) {
  const owner = bytesToHex(chunk.owner());
  const identifier = bytesToHex(chunk.identifier());
  const signature = bytesToHex(chunk.signature());
  const data = Binary.concatBytes(chunk.span(), chunk.payload());
  return socAPI.upload(requestOptions, owner, identifier, signature, data, postageBatchId, options);
}
/**
 * Helper function to create and upload SOC.
 *
 * @param requestOptions  Options for making requests
 * @param signer          The singer interface for signing the chunk
 * @param postageBatchId
 * @param identifier      The identifier of the chunk
 * @param data            The chunk data
 * @param options
 */
export async function uploadSingleOwnerChunkData(requestOptions, signer, postageBatchId, identifier, data, options) {
  assertAddress(postageBatchId);
  const cac = makeContentAddressedChunk(data);
  const soc = await makeSingleOwnerChunk(cac, identifier, signer);
  return uploadSingleOwnerChunk(requestOptions, soc, postageBatchId, options);
}
/**
 * Helper function to download SOC.
 *
 * @param url           The url of the Bee service
 * @param ownerAddress  The singer interface for signing the chunk
 * @param identifier    The identifier of the chunk
 */
export async function downloadSingleOwnerChunk(requestOptions, ownerAddress, identifier) {
  const address = makeSOCAddress(identifier, ownerAddress);
  const data = await chunkAPI.download(requestOptions, bytesToHex(address));
  return makeSingleOwnerChunkFromData(data, address);
}