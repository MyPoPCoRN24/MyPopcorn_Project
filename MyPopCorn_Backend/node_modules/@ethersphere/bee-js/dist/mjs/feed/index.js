import { Binary } from 'cafe-utility';
import { makeSingleOwnerChunkFromData, uploadSingleOwnerChunkData } from "../chunk/soc.js";
import * as chunkAPI from "../modules/chunk.js";
import { fetchLatestFeedUpdate } from "../modules/feed.js";
import { FEED_INDEX_HEX_LENGTH } from "../types/index.js";
import { bytesAtOffset, makeBytes } from "../utils/bytes.js";
import { makeHexEthAddress } from "../utils/eth.js";
import { keccak256Hash } from "../utils/hash.js";
import { bytesToHex, hexToBytes, makeHexString } from "../utils/hex.js";
import { makeBytesReference } from "../utils/reference.js";
import { assertAddress } from "../utils/type.js";
import { makeFeedIdentifier } from "./identifier.js";
const TIMESTAMP_PAYLOAD_OFFSET = 0;
const TIMESTAMP_PAYLOAD_SIZE = 8;
const REFERENCE_PAYLOAD_OFFSET = TIMESTAMP_PAYLOAD_SIZE;
export async function findNextIndex(requestOptions, owner, topic, options) {
  try {
    const feedUpdate = await fetchLatestFeedUpdate(requestOptions, owner, topic, options);
    return makeHexString(feedUpdate.feedIndexNext, FEED_INDEX_HEX_LENGTH);
  } catch (e) {
    if (e?.response?.status === 404) {
      return bytesToHex(makeBytes(8));
    }
    throw e;
  }
}
export async function updateFeed(requestOptions, signer, topic, reference, postageBatchId, options) {
  const ownerHex = makeHexEthAddress(signer.address);
  const nextIndex = options?.index ?? (await findNextIndex(requestOptions, ownerHex, topic, options));
  const identifier = makeFeedIdentifier(topic, nextIndex);
  const at = options?.at ?? Date.now() / 1000.0;
  const timestamp = Binary.numberToUint64BE(Math.floor(at));
  const payloadBytes = Binary.concatBytes(timestamp, reference);
  return uploadSingleOwnerChunkData(requestOptions, signer, postageBatchId, identifier, payloadBytes, options);
}
export function getFeedUpdateChunkReference(owner, topic, index) {
  const identifier = makeFeedIdentifier(topic, index);
  return keccak256Hash(identifier, owner);
}
export async function downloadFeedUpdate(requestOptions, owner, topic, index) {
  const address = getFeedUpdateChunkReference(owner, topic, index);
  const addressHex = bytesToHex(address);
  const data = await chunkAPI.download(requestOptions, addressHex);
  const soc = makeSingleOwnerChunkFromData(data, address);
  const payload = soc.payload();
  const timestampBytes = bytesAtOffset(payload, TIMESTAMP_PAYLOAD_OFFSET, TIMESTAMP_PAYLOAD_SIZE);
  const timestamp = Binary.uint64BEToNumber(timestampBytes);
  const reference = makeBytesReference(payload, REFERENCE_PAYLOAD_OFFSET);
  return {
    timestamp,
    reference
  };
}
export function makeFeedReader(requestOptions, type, topic, owner) {
  return {
    type,
    owner,
    topic,
    async download(options) {
      if (!options?.index && options?.index !== 0) {
        return fetchLatestFeedUpdate(requestOptions, owner, topic);
      }
      const update = await downloadFeedUpdate(requestOptions, hexToBytes(owner), topic, options.index);
      return {
        reference: bytesToHex(update.reference),
        feedIndex: options.index,
        feedIndexNext: ''
      };
    }
  };
}
export function makeFeedWriter(requestOptions, type, topic, signer) {
  const upload = async (postageBatchId, reference, options) => {
    assertAddress(postageBatchId);
    const canonicalReference = makeBytesReference(reference);
    return updateFeed(requestOptions, signer, topic, canonicalReference, postageBatchId, {
      ...options,
      type
    });
  };
  return {
    ...makeFeedReader(requestOptions, type, topic, makeHexEthAddress(signer.address)),
    upload
  };
}